"""
Visualize Saved Powerline Detection Results

This script loads and visualizes previously saved powerline detection results
without needing to re-run the detection algorithm.

Usage:
    python visualize_saved_results.py

Requirements:
    - detected_powerlines.ply (generated by powerline detector)
    - Original PLY file (optional, for context)
"""

import open3d as o3d
import numpy as np
from pathlib import Path
try:
    import plotly.graph_objects as go
    HAS_PLOTLY = True
except ImportError:
    HAS_PLOTLY = False
import os


def visualize_saved_powerlines(powerline_file: str = "detected_powerlines.ply",
                                 original_file: str = "L001.ply",
                                 show_original: bool = True):
    """
    Visualize saved powerline detection results.
    
    Args:
        powerline_file: Path to saved powerline PLY file
        original_file: Path to original point cloud (for context)
        show_original: Whether to show original cloud in background
    """
    data_dir = Path(__file__).parent / "Toronto_3D"
    
    # Load saved powerline results
    powerline_path = data_dir / powerline_file
    
    if not powerline_path.exists():
        print(f"Error: {powerline_file} not found!")
        print(f"Please run the powerline detector first to generate results.")
        return False
    
    print(f"Loading saved powerlines from: {powerline_path}")
    pcd_powerlines = o3d.io.read_point_cloud(str(powerline_path))
    n_powerline_points = len(pcd_powerlines.points)
    print(f"  Loaded {n_powerline_points:,} powerline points")
    
    geometries = []
    
    # Load original point cloud for context (optional)
    if show_original:
        original_path = data_dir / original_file
        if original_path.exists():
            print(f"\nLoading original cloud: {original_path}")
            pcd_original = o3d.io.read_point_cloud(str(original_path))
            
            # Apply same UTM offset
            points = np.asarray(pcd_original.points)
            UTM_OFFSET = np.array([627285, 4842000, 0])
            pcd_original.points = o3d.utility.Vector3dVector(points - UTM_OFFSET)
            
            # Fade the original cloud
            if pcd_original.has_colors():
                colors = np.asarray(pcd_original.colors)
                faded_colors = colors * 0.3 + 0.2
                pcd_original.colors = o3d.utility.Vector3dVector(faded_colors)
            else:
                pcd_original.paint_uniform_color([0.3, 0.3, 0.3])
            
            geometries.append(pcd_original)
            print(f"  Loaded {len(pcd_original.points):,} background points")
        else:
            print(f"  Original file not found: {original_path}")
            print(f"  Visualizing powerlines only...")
    
    # Ensure powerlines are red
    pcd_powerlines.paint_uniform_color([1, 0, 0])
    geometries.append(pcd_powerlines)
    
    # Add coordinate frame for reference
    coord_frame = o3d.geometry.TriangleMesh.create_coordinate_frame(
        size=10.0, origin=[0, 0, 0]
    )
    geometries.append(coord_frame)
    
    # Compute bounding box for powerlines
    points = np.asarray(pcd_powerlines.points)
    print(f"\nPowerline bounds:")
    print(f"  X: [{points[:,0].min():.2f}, {points[:,0].max():.2f}]")
    print(f"  Y: [{points[:,1].min():.2f}, {points[:,1].max():.2f}]")
    print(f"  Z: [{points[:,2].min():.2f}, {points[:,2].max():.2f}]")
    
    # Visualize
    print("\nOpening visualization window...")
    print("Controls:")
    print("  - Left-click + drag: Rotate view")
    print("  - Right-click + drag: Pan view")
    print("  - Scroll wheel: Zoom")
    print("  - Press 'H': Show help")
    print("  - Press 'Q' or ESC: Close window")
    
    try:
        o3d.visualization.draw_geometries(
            geometries,
            window_name="Saved Powerline Detection Results",
            width=1400,
            height=900,
            left=50,
            top=50
        )
        return True
    except Exception as e:
        print(f"\nOpenGL visualization failed: {e}")
        print("Falling back to HTML visualization...")
        return False


def save_html_visualization(powerline_file: str = "detected_powerlines.ply",
                           original_file: str = "L001.ply",
                           output_file: str = "saved_powerlines_visualization.html",
                           show_original: bool = True):
    """
    Save interactive 3D visualization as HTML file using Plotly.
    
    Args:
        powerline_file: Path to saved powerline PLY file
        original_file: Path to original point cloud (optional)
        output_file: Path for output HTML file
        show_original: Whether to include original cloud
    """
    if not HAS_PLOTLY:
        print("Plotly not available. Install with: pip install plotly")
        return False
    
    data_dir = Path(__file__).parent / "Toronto_3D"
    powerline_path = data_dir / powerline_file
    
    if not powerline_path.exists():
        print(f"Error: {powerline_file} not found!")
        return False
    
    print(f"Creating HTML visualization...")
    
    # Load powerlines
    pcd_powerlines = o3d.io.read_point_cloud(str(powerline_path))
    powerline_points = np.asarray(pcd_powerlines.points)
    
    traces = []
    
    # Add original point cloud if available
    if show_original:
        original_path = data_dir / original_file
        if original_path.exists():
            print("  Loading original point cloud...")
            pcd_original = o3d.io.read_point_cloud(str(original_path))
            original_points = np.asarray(pcd_original.points)
            
            # Apply UTM offset
            UTM_OFFSET = np.array([627285, 4842000, 0])
            original_points = original_points - UTM_OFFSET
            
            # Sample for performance
            sample_size = min(80000, len(original_points))
            sample_indices = np.random.choice(len(original_points), sample_size, replace=False)
            points_sample = original_points[sample_indices]
            
            # Get colors
            if pcd_original.has_colors():
                colors_sample = np.asarray(pcd_original.colors)[sample_indices]
                colors_rgb = (colors_sample * 255).astype(np.uint8)
                marker_color = [f'rgb({r},{g},{b})' for r,g,b in colors_rgb]
            else:
                marker_color = 'rgb(150, 150, 150)'
            
            trace_original = go.Scatter3d(
                x=points_sample[:, 0],
                y=points_sample[:, 1],
                z=points_sample[:, 2],
                mode='markers',
                name='Original Cloud',
                marker=dict(
                    size=1,
                    color=marker_color if isinstance(marker_color, list) else 'rgb(150, 150, 150)',
                    opacity=0.3
                )
            )
            traces.append(trace_original)
    
    # Add powerlines in red
    trace_powerlines = go.Scatter3d(
        x=powerline_points[:, 0],
        y=powerline_points[:, 1],
        z=powerline_points[:, 2],
        mode='markers',
        name='Detected Powerlines',
        marker=dict(
            size=2,
            color='rgb(255, 0, 0)',
            opacity=0.9
        ),
        hovertemplate='<b>Powerline</b><br>X: %{x:.2f}<br>Y: %{y:.2f}<br>Z: %{z:.2f}<extra></extra>'
    )
    traces.append(trace_powerlines)
    
    # Create figure
    fig = go.Figure(data=traces)
    
    # Update layout
    fig.update_layout(
        title={
            'text': 'Saved Powerline Detection Results',
            'x': 0.5,
            'xanchor': 'center'
        },
        scene=dict(
            xaxis=dict(
                title='X (m)',
                backgroundcolor="rgb(240, 240, 240)",
                gridcolor="white",
                showbackground=True,
            ),
            yaxis=dict(
                title='Y (m)',
                backgroundcolor="rgb(240, 240, 240)",
                gridcolor="white",
                showbackground=True,
            ),
            zaxis=dict(
                title='Z (m)',
                backgroundcolor="rgb(240, 240, 240)",
                gridcolor="white",
                showbackground=True,
            ),
            aspectmode='data'
        ),
        width=1400,
        height=800,
        hovermode='closest',
        showlegend=True
    )
    
    # Save
    output_path = data_dir / output_file
    fig.write_html(str(output_path))
    print(f"\nâœ“ Interactive visualization saved to {output_path}")
    print(f"  File size: {os.path.getsize(output_path) / (1024*1024):.1f} MB")
    print(f"  Open this file in a web browser to explore the 3D model")
    
    return True


def quick_stats(powerline_file: str = "detected_powerlines.ply"):
    """Print quick statistics about saved powerline results."""
    data_dir = Path(__file__).parent / "Toronto_3D"
    powerline_path = data_dir / powerline_file
    
    if not powerline_path.exists():
        print(f"Error: {powerline_file} not found!")
        return
    
    print("="*60)
    print("SAVED POWERLINE RESULTS - STATISTICS")
    print("="*60)
    
    pcd = o3d.io.read_point_cloud(str(powerline_path))
    points = np.asarray(pcd.points)
    
    print(f"File: {powerline_path.name}")
    print(f"Total points: {len(points):,}")
    
    print(f"\nSpatial extent:")
    print(f"  X range: {points[:,0].max() - points[:,0].min():.2f}m")
    print(f"  Y range: {points[:,1].max() - points[:,1].min():.2f}m")
    print(f"  Z range: {points[:,2].max() - points[:,2].min():.2f}m")
    
    print(f"\nHeight statistics:")
    print(f"  Min height: {points[:,2].min():.2f}m")
    print(f"  Max height: {points[:,2].max():.2f}m")
    print(f"  Mean height: {points[:,2].mean():.2f}m")
    
    # Estimate cable length (approximate)
    x_range = points[:,0].max() - points[:,0].min()
    y_range = points[:,1].max() - points[:,1].min()
    approx_length = np.sqrt(x_range**2 + y_range**2)
    print(f"\nApproximate cable span: {approx_length:.1f}m")
    
    print("="*60)


def main():
    """Main entry point."""
    
    print("\n" + "="*60)
    print("VISUALIZE SAVED POWERLINE RESULTS")
    print("="*60 + "\n")
    
    # Show statistics
    quick_stats()
    
    print("\nVisualization options:")
    print("  1. Powerlines only (OpenGL)")
    print("  2. Powerlines + original cloud (OpenGL)")
    print("  3. Interactive HTML (recommended for headless)")
    
    choice = input("\nEnter choice (1, 2, or 3, default=3): ").strip() or "3"
    
    if choice == "3":
        # Use HTML visualization (works in headless mode)
        show_original = input("Include original point cloud? (y/n, default=y): ").strip().lower() != "n"
        save_html_visualization(
            powerline_file="detected_powerlines.ply",
            original_file="L001.ply",
            output_file="saved_powerlines_visualization.html",
            show_original=show_original
        )
    else:
        # Try OpenGL visualization
        show_original = choice == "2"
        success = visualize_saved_powerlines(
            powerline_file="detected_powerlines.ply",
            original_file="L001.ply",
            show_original=show_original
        )
        
        if not success:
            # Fallback to HTML
            print("\n" + "="*60)
            print("Generating HTML visualization as fallback...")
            print("="*60)
            save_html_visualization(
                powerline_file="detected_powerlines.ply",
                original_file="L001.ply",
                output_file="saved_powerlines_visualization.html",
                show_original=show_original
            )


if __name__ == "__main__":
    main()
